//
// Created by Casey Idzikowski on 5/12/25.
//


#pragma once

#include <vector>
#include <cmath>
#include <cstdlib>
#include <cstdint>
#include <algorithm>
#include "SoundSource.h"
#include "SoundDefinitions.h"
#include "SoundHelpers.cpp"

// region SoundSources

/**
 * A class for generating Samples that are created using
 * a Sine wave.
 *
 * Requires a phase to keep track of the current position relative to
 * the buffer. Similar to what needs to be done with pre-loaded buffers.
 */
class SineWaveSoundSource : public SoundSource {
public:

    using SoundSource::SoundSource;

    void addSoundToBuffer(float *audioData, int numSamples) override {
        static float frequency = 440.0f;     // A4 tone
        const float phaseIncrement = (2.0f * kPi * frequency) / kSampleRate;
        static float phase = 0.0f;

        for (int i = 0; i < numSamples; ++i) {
            float sample = volume * sinf(phase);
            audioData[i] += sample;
            phase += phaseIncrement;
            if (phase > 2.0f * kPi) phase -= 2.0f * kPi;  // keep phase bounded
        }
    }

    SoundDefinitions::SoundSourceType getSoundSourceType() override {
        return SineWaveSourceType;
    }

private:
    static constexpr SoundDefinitions::SoundSourceType SineWaveSourceType = SoundDefinitions::SoundSourceType::SINE_WAVE;
    static constexpr float kPi = 3.14159265f;
    static constexpr float kSampleRate = 48000.0f;
};

/**
 * A class for generating white noise samples for sound mixing.
 *
 * Example of a sample generated by a single line of code through random
 * floats.
 */
class WhiteNoiseSoundSource : public SoundSource {
public:
    using SoundSource::SoundSource;

    void addSoundToBuffer(float *audioData, int numSamples) override {
        for (int i = 0; i < numSamples; i++) {
            audioData[i] += makeWhiteNoise() * volume;
        }
    }

    SoundDefinitions::SoundSourceType getSoundSourceType() override {
        return WhiteNoiseSourceType;
    }

private:
    /**
     * Helper function to generate a white noise sample.
     * @return A random float between -0.6 and 0.6
     */
    static float makeWhiteNoise() {
        return CommonSounds::whiteNoise();
    }

    static constexpr SoundDefinitions::SoundSourceType WhiteNoiseSourceType = SoundDefinitions::SoundSourceType::WHITE_NOISE;
};

class WindSoundSource : public SoundSource {
public:
    using SoundSource::SoundSource;

    void addSoundToBuffer(float *audioData, int numSamples) override {
        for (int i = 0; i < numSamples; i++) {
            audioData[i] += makeWind() * volume;
        }
    }

    SoundDefinitions::SoundSourceType getSoundSourceType() override {
        return WindSourceType;
    }

private:

    float makeWind() {
        return lowPassFilter.process(CommonSounds::whiteNoise() * 0.4f);
    }

    LowPassFilter lowPassFilter{0.05f};

    static constexpr SoundDefinitions::SoundSourceType WindSourceType = SoundDefinitions::SoundSourceType::WIND;

};

/**
 * Rain sound source generator
 */
class RainSoundSource : public SoundSource {
public:
    using SoundSource::SoundSource;

    void addSoundToBuffer(float *audioData, int numSamples) override {
        for (int i = 0; i < numSamples; i++) {
            audioData[i] += makeRain() * volume;
        }
    }

    SoundDefinitions::SoundSourceType getSoundSourceType() override {
        return RainSourceType;
    }

private:

    /**
     * Rain noise is random droplets on a backgroun of soft static (white noise).
     * @return Rain noise that is clamped
     */
    static float makeRain() {
        float hiss = CommonSounds::whiteNoise() * 0.2f;
        float droplet = (rand() % 1600 == 0) ? 1.0f : 0.0f;
        return CommonSounds::clampf(hiss + droplet, -1.0f, 1.0f);
    }

    static constexpr SoundDefinitions::SoundSourceType RainSourceType = SoundDefinitions::SoundSourceType::RAIN;
};

/**
 * A CampFire Sound Source. Mimics campfire sounds using crackle bursts with a soft white noise base.
 *
 */
class CampfireSoundSource : public SoundSource {
public:
    using SoundSource::SoundSource;

    void addSoundToBuffer(float *audioData, int numSamples) override {
        for (int i = 0; i < numSamples; i++) {
            audioData[i] += makeCampFire() * volume;
        }
    }

    SoundDefinitions::SoundSourceType getSoundSourceType() override {
        return CampFireSourceType;
    }

private:

    float makeCampFire() {
        float base = CommonSounds::whiteNoise() * 0.03f;

        if(--crackleCountdown <= 0) {
            crackleCountdown = rand() % 1000 + 400;
            crackleBurst = (CommonSounds::whiteNoise() + 1.0f) * 0.5f;
        }
        float crackle = crackleBurst * CommonSounds::whiteNoise();
        crackleBurst *= 0.97f; // crackle burst decay

        return CommonSounds::clampf(base + crackle, -1.0f, 1.0f);
    }

    static constexpr SoundDefinitions::SoundSourceType CampFireSourceType = SoundDefinitions::SoundSourceType::CAMPFIRE;

    int crackleCountdown = 1000;
    float crackleBurst = 0.0f;
};

// endregion